# What is Syntax analysis/Parsing? [LINK][https://www.naukri.com/code360/library/syntax-analysis-4359]
Syntax analysis, also known as parsing, is a key process in computer science, particularly in the area of compilers, which are programs that translate code written in a programming language into a form that a computer can understand. The role of syntax analysis is to check the code for correct syntax and to organize the code into a structured format that the computer can use to execute the program.

**Key Functions of Syntax Analysis:**

- Error Checking: Ensures that the code written adheres to the defined syntax rules of the programming language.
- Structure Organization: Converts code into a structured format, such as a parse tree or an abstract syntax tree, which represents the hierarchical relationship of code elements.  

**Steps Involved in Syntax Analysis:**

- Tokenization: Breaks down the code into basic elements or tokens (e.g., keywords, variables, operators).
- Rule Application: Applies the programming language's syntax rules to the tokens to verify their correct arrangement.
- Tree Construction: Builds a parse tree or abstract syntax tree from tokens if they follow the syntax rules correctly, illustrating the syntactic structure of the code.

# ROLE OF PARSING?
# Ambiguity in Grammar

A grammar is said to be ambiguous if there exists more than one leftmost derivation or more than one rightmost derivation or more than one parse tree for the given input string. If the grammar is not ambiguous, then it is called unambiguous.

If the grammar has ambiguity, then it is not good for compiler construction. No method can automatically detect and remove the ambiguity, but we can remove ambiguity by re-writing the whole grammar without ambiguity.

Let us consider a grammar G with the production rule

1. E → I  
2. E → E + E  
3. E → E * E  
4. E → (E)  
5. I → ε | 0 | 1 | 2 | ... | 9  

**Solution:**

For the string "3 * 2 + 5", the above grammar can generate two parse trees by leftmost derivation:

![Ambiguity in Grammar](https://static.javatpoint.com/tutorial/automata/images/automata-ambiguity-in-grammar-solution1.png)

# Abstract syntax tree
An Abstract Syntax Tree, or AST, is a representation of the structure of a programming language. It is a tree-like structure that is composed of nodes, each of which represents a language element like a variable, operator, or keyword. ASTs are often used to represent code written in a specific programming language, such as Python or C++.
- An AST is essentially a simplified version of a parse tree. 
- The nodes of an AST are abstracted away from the details of the syntax of the language, making it easier to reason about the structure of the code. 
- This abstraction allows for more efficient processing, as the details of the language are removed. Additionally, ASTs are often easier to understand than parse trees, as they are more concise and easier to read.
# AST vs Parse-Tree

| Factor             | Abstract Syntax Tree                                                                                                          | Parse Tree                                                                                                                     |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **Structure**      | An AST is composed of symbols, such as operators, identifiers, and keywords. These symbols are organized in a tree structure. | A parse tree is composed of tokens, such as terminal and non-terminal symbols. These tokens are organized in a tree structure. |
| **Representation** | An AST is represented using a standard tree structure, with each node representing a particular symbol or rule.               | A parse tree is represented using a graph structure, with each node representing a particular token or rule.                   |
| **Generation**     | An AST is generated by the compiler from the source code.                                                                     | A parse tree is generated by the parser from the source code.                                                                  |
| **Usage**          | An AST is used to analyze the source code and optimize it for compilation.                                                    | A parse tree is used to check the syntactic correctness of the source code.                                                    |
| **Expressiveness** | An AST is more expressive than a parse tree, as it provides more information about the source code.                           | A parse tree is less expressive than an AST, as it only provides basic information about the source code.                      |
| **Efficiency**     | An AST is more efficient than a parse tree, as it requires fewer operations to generate.                                      | A parse tree is less efficient than an AST, as it requires more operations to generate.                                        |
| **Size**           | An AST is smaller than a parse tree, as it contains fewer symbols.                                                            | A parse tree is larger than an AST, as it contains more tokens.                                                                |
| **Complexity**     | An AST is simpler than a parse tree, as it is generated from fewer operations.                                                | A parse tree is more complex than an AST, as it is generated from more operations.                                             |
| **Comprehension**  | An AST is easier to comprehend than a parse tree, as it contains more information about the source code.                      | A parse tree is harder to comprehend than an AST, as it contains less information about the source code.                       |

# Eliminate Left Recursion
![[Pasted image 20240609011735.png]]
# Parsing techniques:
## Top down parser
- TDP with full backtracking(brute force method)
- TDP without backtracking
	- Recursive Decent 
	- Non-recursive decent ( LL(1) ) OR Predictive parser
## Bottom Up parser
1. LR 
2. CLR
3. SLR
4. LALR

# Top down vs Bottom up Parser
|Top-Down Parsing|Bottom-Up Parsing|
|---|---|
|It is a parsing strategy that first looks at the highest level of the parse tree and works down the parse tree by using the rules of grammar.|It is a parsing strategy that first looks at the lowest level of the parse tree and works up the parse tree by using the rules of grammar.|
|[Top-down parsing](https://www.geeksforgeeks.org/classification-of-top-down-parsers/) attempts to find the left most derivations for an input string.|[Bottom-up parsing](https://www.geeksforgeeks.org/bottom-up-or-shift-reduce-parsers-set-2/) can be defined as an attempt to reduce the input string to the start symbol of a grammar.|
|In this parsing technique we start parsing from the top (start symbol of parse tree) to down (the leaf node of parse tree) in a top-down manner.|In this parsing technique we start parsing from the bottom (leaf node of the parse tree) to up (the start symbol of the parse tree) in a bottom-up manner.|
|This parsing technique uses Left Most Derivation.|This parsing technique uses Right Most Derivation.|
|The main leftmost decision is to select what production rule to use in order to construct the string.|The main decision is to select when to use a production rule to reduce the string to get the starting symbol.|
|Example: Recursive Descent parser.|Example: ItsShift Reduce parser.|

# LL(1) OR Predictive OR Non recursive decent Parser
- first and follow [link][https://youtu.be/lhQqq5FfzMU?si=cYjzDmBoBAhuN2zk] [examples][https://youtu.be/T7twzNPspTg?si=IXVGIIQxehZHmFnU]
- LL(1) [link][https://youtu.be/en0Mptigzkw?si=gzzZkqhqZ877Fwi4]
****LL(1) Parsing:**** Here the 1st ****L**** represents that the scanning of the Input will be done from the Left to Right manner and the second ****L**** shows that in this parsing technique, we are going to use the Left most Derivation Tree. And finally, the ****1**** represents the number of look-ahead, which means how many symbols are you going to see when you want to make a decision.

****Essential conditions to check first are as follows:**** 

1. The grammar is free from left recursion.
2. The grammar should not be ambiguous.
3. The grammar has to be left factored in so that the grammar is deterministic grammar.

These conditions are necessary but not sufficient for proving a LL(1) parser.

## ****Algorithm to construct LL(1) Parsing Table:**** 

****Step 1:****  First check all the essential conditions mentioned above and go to step 2.

****Step 2:**** Calculate First() and Follow() for all non-terminals.

1.  [****First****](https://www.geeksforgeeks.org/first-set-in-syntax-analysis/)****():**** If there is a variable, and from that variable, if we try to drive all the strings then the beginning Terminal Symbol is called the First. 
2. [Follow](https://www.geeksforgeeks.org/follow-set-in-syntax-analysis/)(): What is the Terminal Symbol which follows a variable in the process of derivation. 

****Step 3:**** For each production A –> α. (A tends to alpha)

1. Find First(α) and for each terminal in First(α), make entry A –> α in the table.
2. If First(α) contains ε (epsilon) as terminal, then find the Follow(A) and for each terminal in Follow(A), make entry A –>  ε in the table.
3. If the First(α) contains ε and Follow(A) contains $ as terminal, then make entry A –>  ε in the table for the $.  
    To construct the parsing table, we have two functions:

# LR parser
**Description of LR parser :**  
The term parser LR(k) parser, here the L refers to the left-to-right scanning, R refers to the rightmost derivation in reverse and k refers to the number of unconsumed “look ahead” input symbols that are used in making parser decisions. Typically, k is 1 and is often omitted. A context-free grammar is called LR (k) if the LR (k) parser exists for it. This first reduces the sequence of tokens to the left. But when we read from above, the derivation order first extends to non-terminal.

1. The stack is empty, and we are looking to reduce the rule by S’→S$.
2. Using a “.” in the rule represents how many of the rules are already on the stack.
3. A dotted item, or simply, the item is a production rule with a dot indicating how much RHS has so far been recognized. Closing an item is used to see what production rules can be used to expand the current structure. It is calculated as follows:

**Rules for LR parser :**  
The rules of LR parser as follows.

1. The first item from the given grammar rules adds itself as the first closed set.
2. If an object is present in the closure of the form A→ α. β. γ, where the next symbol after the symbol is non-terminal, add the symbol’s production rules where the dot precedes the first item.
3. Repeat steps (B) and (C) for new items added under (B).

**LR parser algorithm :**  
LR Parsing algorithm is the same for all the parser, but the parsing table is different for each parser. It consists following components as follows.

1. **Input Buffer –**   
    It contains the given string, and it ends with a $ symbol.  
     
2. **Stack –**   
    The combination of state symbol and current input symbol is used to refer to the parsing table in order to take the parsing decisions.

**Parsing Table** :   
Parsing table is divided into two parts- Action table and Go-To table. The **action table** gives a grammar rule to implement the given current state and current terminal in the input stream. There are four cases used in action table as follows.

1. Shift Action- In shift action the present terminal is removed from the input stream and the state _**n**_ is pushed onto the stack, and it becomes the new present state.
2. Reduce Action- The number _**m**_ is written to the output stream.
3. The symbol _**m**_ mentioned in the left-hand side of rule _**m**_ says that state is removed from the stack.
4. The symbol _**m**_ mentioned in the left-hand side of rule **m** says that a new state is looked up in the goto table and made the new current state by pushing it onto the stack.

An accept - the string is accepted
No action - a syntax error is reported

**Note –**  
The **go-to table** indicates which state should proceed.

**LR parser diagram :**

![[Pasted image 20240609005004.png]]