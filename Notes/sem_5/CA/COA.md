[COA syllabus](obsidian://open?vault=Notes&file=sem_5%2Fsem_5%266_syllabus.pdf#page=10)	
[Last minute notes GFG](https://www.geeksforgeeks.org/last-minute-notes-computer-organization/)
### UNIT 1 [notes](obsidian://open?vault=Notes&file=sem_5%2FCA%2FCoA%20Notes%20Unit-1.pdf):
- What is computer architecture? Role of CA.
	[Computer architecture Tutorials Point](https://www.tutorialspoint.com/what-is-computer-architecture)
	Role of Computer Architecture:
	1. **System Design and Organization:**
	2. **Performance Optimization:**
	3. **Energy Efficiency:**
	4. **Scalability:**
	5. **Compatibility and Interoperability:**
	6. **Security:**
	7. **Technological Advancements:**
	8. **Adaptability to Changing Workloads:**
	9. **Reliability and Fault Tolerance:**
	10. **Innovation and Emerging Technologies:**
	
- Evolution of computer architecture:
	The evolution of computer architecture spans several decades and is marked by significant milestones that have shaped the way computers are designed and function. Here is a brief overview of the key stages in the evolution of computer architecture:
	
	1. **First Generation (1940s-1950s): Vacuum Tubes and Plugboards**
	   - The first electronic computers, such as ENIAC (Electronic Numerical Integrator and Computer), used vacuum tubes for processing and magnetic drums for memory.
	   - Programming was done using plugboards and switches, making it a labor-intensive process.
	
	2. **Second Generation (1950s-1960s): Transistors and Assembly Language**
	   - Transistors replaced vacuum tubes, leading to smaller, more reliable, and faster computers.
	   - Assembly language was introduced, providing a more human-readable way to program computers.
	   - Magnetic core memory became a standard for primary storage.
	
	3. **Third Generation (1960s-1970s): Integrated Circuits and High-Level Languages**
	   - Integrated circuits (ICs) were developed, combining multiple transistors on a single chip, leading to smaller and more powerful computers.
	   - High-level programming languages like Fortran and COBOL were introduced, simplifying programming.
	
	4. **Fourth Generation (1970s-1980s): Microprocessors and Personal Computers**
	   - The invention of the microprocessor allowed the integration of the entire CPU on a single chip.
	   - The development of personal computers, like the IBM PC, Apple II, and Commodore 64, brought computing to homes and businesses.
	   - Operating systems, such as MS-DOS, began to play a crucial role in managing computer resources.
	
	5. **Fifth Generation (1980s-Present): VLSI, Parallel Processing, and Networking**
	   - Very Large Scale Integration (VLSI) technology allowed the integration of millions of transistors on a single chip.
	   - Parallel processing and supercomputers became more common, enabling the simultaneous execution of multiple tasks.
	   - Networking technologies, including the development of the Internet, transformed the way computers communicate and share information.
	
	6. **Sixth Generation (Present and Beyond): AI, Quantum Computing, and Neuromorphic Computing**
	   - Current developments include a focus on artificial intelligence (AI) and machine learning, leading to specialized hardware like GPUs (Graphics Processing Units) for parallel processing.
	   - Quantum computing is a promising area that leverages the principles of quantum mechanics for vastly improved computational power.
	   - Neuromorphic computing aims to mimic the structure and function of the human brain for more efficient and adaptive computing.

* Computer architecture VS Computer Organization:
	[CA vs CO (tutorials point)](https://www.tutorialspoint.com/differences-between-computer-architecture-and-computer-organization)

* Von Neumann Architecture:
  [JAVATPOINT: Von-Neumann Model](https://www.javatpoint.com/von-neumann-model)
  [MEDIUM: Impact of Von-Neumann Model](https://medium.com/@jaroeducationnew2023/what-is-von-neumann-architecture-and-its-impact-on-modern-computing-d70a21efd8a1)

* Fixed and Floating point representations:
	[Fixed and floating point representation](https://www.codingninjas.com/studio/library/fixed-and-floating-point-representation)
* Digital algorithms for add, substract, multiply and divide
	[Numericals pdf](obsidian://open?vault=Notes&file=sem_5%2FCA%2FCoA%20numerical.pdf)

### UNIT 2 [notes](obsidian://open?vault=Notes&file=sem_5%2FCA%2FCoa%20Unit%202.pdf)

 - Instruction cycle video [FDX](https://www.youtube.com/watch?v=Z5JC9Ve1sfI)
 - Hardwired VS microprogrammed control unit
	   [video](https://youtu.be/l1vBkZWyELk?si=6pzRBnC7BIK8r2lf)
### UNIT 3 [notes](obsidian://open?vault=Notes&file=sem_5%2FCA%2FCoa%20Unit%203.pdf)

### UNIT 4 [notes](obsidian://open?vault=Notes&file=sem_5%2FCA%2FCA%20unit%204.pdf)